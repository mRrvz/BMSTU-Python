# Название: Интеграл

# Назначение: вычисляет определенный интеграл с помощью метода Буля и 
# центральных прямоугольников

'''Тестовый пример:

Ввод:
Введите через пробел границы:  0 3
Введите через пробел количество разбиений (n1, n2 кратные 4):  4 8
Введите погрешность вычислений (eps > 0):  0.1

Вывод:
Результат расчета через формулу Ньютона-Лейбница:  9

 ┌──────────────────────────┬──────────────────────┬─────────────────────┐
 │           Метод          │         n1 = 4       │         n2 = 8      │
 ├──────────────────────────┼──────────────────────┼─────────────────────┤
 │Центральные прямоугольники│          8.859       │         8.965       │
 ├──────────────────────────┼──────────────────────┼─────────────────────┤
 │        Метод Буля        │            9         │           9         │
 └──────────────────────────┴──────────────────────┴─────────────────────┘


Расчет с заданной точностью для метода центральных прямоугольников:


Потребовалось 8 разбиений
Значение интеграла =  8.965
Абсолютная ошибка 0.035
Относительная ошибка 0.004
 
'''

# f - данная функция
# F - первообразная данной функции
# n1, n2 - количество разбиений (для 2 случаев)
# eps - погрешность
# k - счетчик
# a, b - границы определенного интеграла
# step_1, step_2 - шаг (для 2 случаев)
# orig_res - результат вычисления по формуле Ньютона - Лейбница
# res_pr_1, res_pr_2 - результат вычисления методом центральных прямоугольников
# (для 2 случаев)
# res_bul_1, res_bul_2 - результат вычисления методом Буля (для 2 случаев)
# res_pr_er - результат вычисления менее точным методом с погрешностью
# abs_err - абсолютная ошибка
# otn_err - относительная ошибка

from math import log

# Задание функции
def f(x):
    return log(x) * log(x) / x

# Задание первообразной функции
def F(x):
    return log(x) * log(x) * log(x) / 3

# Ввод значений с проверкой
while True:
    a, b = map(float, input('Введите через пробел границы:  ').split())
    if a >= b:
        print('Левая граница должна быть меньше правой!')
    else:
        break
    
while True:
    n1, n2 = map(int, input('Введите через пробел количество разбиений (n1, n2\
 кратные 4):  ').split())
    if n1 <= 0 or n2 <= 0:
        print('Количество разбиений должно быть больше 0! Введите еще раз!')
    elif n1%4 != 0 or n2%4 != 0:
        print('n1 и n2 должны быть кратны 4! Введите еще раз!')
    else:
        break

while True:
    eps = float(input('Введите погрешность вычислений (eps > 0):  '))
    if eps <= 0:
        print('eps > 0!!!')
    else:
        break

# Расчет шагов и результата по формуле Ньютона - Лейбница
step_1 = (b - a) / n1
step_2 = (b - a) / n2
orig_res = F(b) - F(a)
print('\nРезультат расчета через формулу Ньютона-Лейбница: ',
      '{:0.8f}'.format(orig_res), '\n\n')

res_pr_1 = res_pr_2 = res_bul_1 = res_bul_2 = 0

#Расчет значений методами центральных прямоугольников и Буля
for i in range(n1):
    x = a + step_1 * (i + 0.5)
    res_pr_1 += f(x) * step_1
    
for i in range(n2):
    x = a + step_2 * (i + 0.5)
    res_pr_2 += f(x) * step_2

res_pr_1 = round(res_pr_1, 15)
res_pr_2 = round(res_pr_2, 15)
x = a
s = 0

for i in range(n1//4):
    x += step_1 * 4
    res_bul_1 += 2 * step_1 * (7 * f(x - step_1 * 4) + 32 * f(x - step_1 * 3) + 12\
* f(x - step_1 * 2) + 32 * f(x - step_1) + 7 * f(x)) / 45

x = a
s=0

for i in range(n2//4):
    x += step_2 * 4
    res_bul_2 += 2 * step_2 * (7 * f(x - step_2 * 4) + 32 * f(x - step_2 * 3) + 12\
* f(x - step_2 * 2) + 32 * f(x - step_2) + 7 * f(x)) / 45



# Вывод таблицы
print(' ┌──────────────────────────┬─────────────────\
─────┬─────────────────────┐\n',
      '│           Метод          │       n1 =', str(n1).ljust(9),'│     n2 =',
     str(n2).ljust(10),'│\n',
      '├──────────────────────────┼──────────────────\
────┼─────────────────────┤\n'
      ' │Центральные прямоугольники│ ','{:14.7f}     '.format(res_pr_1),'│ ',
     '{:14.7f}    '.format(res_pr_2), '│\n'
      ' ├──────────────────────────┼──────────────────\
────┼─────────────────────┤\n'
     ' │        Метод Буля        │ ','{:14.7f}     '.format(res_bul_1),'│ ',
     '{:14.7f}    '.format(res_bul_2), '│\n',
     '└──────────────────────────┴──────────────────\
────┴─────────────────────┘\n')
k = 1

# Расчет результата с погрешностью
res_pr_er = 0
while abs(orig_res - res_pr_er) >= eps and k < 1048576:
    res_pr_er = 0
    step_er = (b - a) / k
    x = a + step_er * 0.5
    for i in range(k):
        res_pr_er += f(x) * step_er
        x += step_er
    k *= 2
k //= 2

# Расчет относительной и абсолютной ошибок и вывод значений
print('\n\nРасчет с заданной точностью для метода центральных прямоугольников:\
\n\n')
abs_err = abs(orig_res - res_pr_er)
otn_err = abs_err / orig_res
if k == 1048576 // 2:
    print('\nНеобходимая точность не достигнута за 1 048 576 \
разбиений')
    print('Значение интеграла:  ', '{0:0.7f}'.format(res_pr_err))
    print('Абсолютная ошибка:  ', '{0:0.8f}'.format(abs_err))
    print('Относительная ошибка:  ', '{0:0.8f}'.format(otn_err))
else:
    print('Потребовалось', k, 'разбиений')
    print('Значение интеграла = ', '{0:0.7f}'.format(res_pr_er))
    print('Абсолютная ошибка', '{0:0.8f}'.format(abs_err))
    print('Относительная ошибка', '{0:0.8f}'.format(otn_err))

